/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include "STM32F103x8.h"
#include "stm32f103x8_gpio_driver.h"
#include "lcd.h"
#include "keypad.h"
#include "stm32f103x8_EXTI_driver.h"
#include "stm32f103x8_USART_driver.h"
#include "stm32f103x8_SPI_driver.h"
#include "stm32f103x8_I2C_driver.h"
#include "I2C_Slave_EEPROM.h"

#define OS_SET_PSP(add)  		__asm volatile("mov r0,%0 \n\t msr psr,r0" : : "r"(add))
#define OS_SWITCH_SP_To_PSP		__asm volatile("mrs r0,CONTROL \n\t mov r1,#0x02 \n\t orr r0,r0,r1 \n\t msr CONTROL,r0")
#define OS_SWITCH_SP_To_MSP		__asm volatile("mrs r0,CONTROL \n\t mov r1,#0x05 \n\t and r0,r0,r1 \n\t msr CONTROL,r0")
#define OS_Generate_Exception	__asm volatile("SVC #0x3")


#define TaskA_Stack_Size 100
#define TaskB_Stack_Size 100
extern int _estack;
//main stack
unsigned int _S_MSP = &_estack;
unsigned int _E_MSP;

//process stack task a
unsigned int _S_PSP_TA;
unsigned int _E_PSP_TA;

//process stack task b
unsigned int _S_PSP_TB;
unsigned int _E_PSP_TB;


 uint8_t TASKA_flag , TASKB_flag,IRQ_Flag = 0;

 enum CPUAccessLevel{
	 privileged,
	 unprivileged
 };

 void SWITCH_CPU_AcessLevel(enum CPUAccessLevel level){
	 switch(level){
	 case privileged:
		 __asm("mrs r3,CONTROL \n\t"
				 "lsr r3,r3,#0x1 \n\t"
				 "lsl r3,r3,#0x1  \n\t"
				 "msr CONTROL,r3");
		 break;
	 case unprivileged:
		 __asm("mrs r3,CONTROL \n\t"
				 "orr r3,r3,#0x1 \n\t"
				 "msr CONTROL,r3");
				 break;
	 }
 }
 void SVC_Handler(){
 	SWITCH_CPU_AcessLevel(privileged);
 }
void EXTI9_CALLBACK(void)
{
	if(IRQ_Flag==0){
		TASKA_flag=1;
		TASKB_flag=0;
		IRQ_Flag=1;
	}else{
		TASKB_flag=1;
		TASKA_flag=0;
		IRQ_Flag=0;
	}
}
int TASKA(int a ,int b ,int c){
	return a+b+c;
}
int TASKB(int a ,int b ,int c,int d){
	return a+b+c+d;
}
void mainOS(){
	_E_MSP=_S_MSP-512;
	_S_PSP_TA = _E_MSP - 8;
	_E_PSP_TA = _S_PSP_TA - TaskA_Stack_Size;

	_S_PSP_TB = _E_PSP_TA - 8;
	_E_PSP_TB = _S_PSP_TB - TaskB_Stack_Size;

	while(1){
		__asm("NOP");
		if(TASKA_flag){
			//set psp register to psp task a
			OS_SET_PSP(_S_PSP_TA);
			//set sp to ->psp
			OS_SWITCH_SP_To_PSP;
			//switch to unprivilded mode
			SWITCH_CPU_AcessLevel(unprivileged);
			int x = TASKA(1,2,3);
			//switch to privileged
			OS_Generate_Exception;
			//set sp to ->msp
			OS_SWITCH_SP_To_MSP;
		}else if(TASKB_flag){
			//set psp register to psp task B
			OS_SET_PSP(_S_PSP_TB);
			//set sp to ->psp
			OS_SWITCH_SP_To_PSP;
			//switch to unprivilded mode
			SWITCH_CPU_AcessLevel(unprivileged);
			int x = TASKB(2,3,4,5);
			//switch to privileged
			OS_Generate_Exception;
			//set sp to ->msp
			OS_SWITCH_SP_To_MSP;
		}
	}
}

int main(void)
{
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();

	//Set EXTI Configuration
	EXTI_PinConfig_t EXTIConfig;
	EXTIConfig.EXTI_PIN = EXTI9PB9;
	EXTIConfig.Trigger_Case = EXTI_Trigger_RISING;
	EXTIConfig.P_IRQ_CallBack = EXTI9_CALLBACK;
	EXTIConfig.IRQ_EN = EXTI_IRQ_Enable;
	MCAL_EXTI_GPIO_Init(&EXTIConfig);


	mainOS();
	IRQ_Flag = 1;

	while (1)
	{
		if(IRQ_Flag)
		{
			IRQ_Flag = 0;
		}
		else { /* Misra */ }
	}


}
